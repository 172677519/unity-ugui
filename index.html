<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Evaluation of the Unity 4.6 New UI System : " />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Evaluation of the Unity 4.6 New UI System</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/jaredoc/unity-ugui">View on GitHub</a>

          <h1 id="project_title">Evaluation of the Unity 4.6 New UI System</h1>
          <h2 id="project_tagline"></h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/jaredoc/unity-ugui/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/jaredoc/unity-ugui/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="unity46%E6%96%B0ui%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2ugui" class="anchor" href="#unity46%E6%96%B0ui%E7%B3%BB%E7%BB%9F%E5%88%9D%E6%8E%A2ugui"><span class="octicon octicon-link"></span></a>Unity4.6新UI系统初探(uGUI)</h1>

<h1>
<a name="%E5%BC%95%E8%A8%80" class="anchor" href="#%E5%BC%95%E8%A8%80"><span class="octicon octicon-link"></span></a>引言</h1>

<p>Unity终于在即将到来的<strong>4.6</strong>版本内集成了<strong>所见即所得</strong>的UI解决方案<a href="http://blogs.unity3d.com/2014/05/28/overview-of-the-new-ui-system/">(视频)</a>。事实上从近几个版本开始，Unity就在为这套系统做技术扩展，以保证最终能实现较理想的UI系统。本文试图通过初步的介绍和试用，让读者对这套系统有大体的了解，以便更进一步评估这套UI系统好不好用，适合用在什么项目。为了避免坑挖太深，更进一步的试用和评估我将在下一篇文章中进行测试。为论述方便，下文将这套New UI System简称为<strong>uGUI</strong>，并且以<strong>X-UI</strong>指代现有第三方UI插件。</p>

<p>（测试只针对Unity 4.6.0 beta 10，正式版可能会有所出入。目前Unity没提供文档，本人半桶水，欢迎群众在微博或Issues里吐槽！）</p>

<h1>
<a name="rect-transform" class="anchor" href="#rect-transform"><span class="octicon octicon-link"></span></a>Rect Transform</h1>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/RectTransform.png" alt="Rect Transform"></p>

<p>Rect Transform继承自Transform，是uGUI相比X-UI最显著的区别[<a href="#why_transform">注1</a>]。当你为Empty GameObject加入一个UI Component时，Transform会自动转换为Rect Transform。Rect Transform尽量整合了X-UI常见的<strong>anchor</strong>(相对父物体的锚点), <strong>pivot</strong>(中点), <strong>stretch</strong>(拉伸)等属性。值得一提的是，这里的<strong>anchor</strong>是Rect而非Vector2，因为它不仅用于偏移，而且用于缩放。点击Rect Transform上的准心图标，还能在弹出的<strong>Anchor Presets</strong>面板中对其进行快速设置。</p>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/AnchorPresets.png" alt="Anchor Presets"></p>

<p>这个面板还是不够直观，我们可以把它看成一张表，上面四个图标用于设置列，左边四个图标用于设置行，也可以直接点击里面的16个图标同时设置行和列。强大的地方是，按住<strong>shift</strong>时能同时设置<strong>pivot</strong>，这时能发现控件虽然不动但position已经在改变。如果按住<strong>alt</strong>，则设置anchor的同时设置<strong>position</strong>。如果shift和alt同时按住，那么你就能同时设置anchor, pivot和position。这个操作方式比起X-UI，真的高明很多，对多分辨率适配很有帮助。</p>

<p>除此之外，Rect Transform还提供了Blueprint和Lock Rect选项，前者用于对旋转过的元素进行定位，后者据说明是能在设置anchor时保持位置不变，暂时没搞明白。</p>

<h1>
<a name="%E6%8E%92%E5%BA%8F" class="anchor" href="#%E6%8E%92%E5%BA%8F"><span class="octicon octicon-link"></span></a>排序</h1>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/SortHierarchy.png" alt="SortHierarchy"></p>

<p>uGUI可以直接在Hierarchy面板中上下拖拽来对渲染进行排序(支持程序控制)，越上面的UI会越先被渲染，相比X-UI的global depth排序，这样的拖拽设计很讨好用户。同时在结构上则和ex2D采用的local depth类似，这样GO只和同级其它GO进行排序，开发组件会很方便。需要注意的是，这里排序只是相对UI而言，其它3D物体还是按原先的次序渲染，并且UI总是渲染在3D物体上面。这就导致你不能像用ex2D那样直接将粒子系统插入到两个UI之间。</p>

<h1>
<a name="%E6%8E%A7%E4%BB%B6" class="anchor" href="#%E6%8E%A7%E4%BB%B6"><span class="octicon octicon-link"></span></a>控件</h1>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/UiComponent.png" alt="UI Component"></p>

<p>uGUI自带了以上控件，其中Image用于显示Sprite，Raw Image用于显示Texture，Image Mask和Rect Mask用于clipping。所有控件都是MonoBehaviour，可以直接从Inspector里拖到其它GameObject上。</p>

<h4>
<a name="image" class="anchor" href="#image"><span class="octicon octicon-link"></span></a>Image</h4>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/Image.png" alt="Image"></p>

<p>uGUI用Image控件显示图片，图片就是一个Sprite，这意味着Pro用户不用再制作atlas了，相比X-UI是个大进步，Free用户一样可以手动做Packing。Image提供了<strong>Simple</strong>, <strong>Sliced</strong>, <strong>Tiled</strong>, <strong>Filled</strong>四种效果，和X-UI保持一致。</p>

<h4>
<a name="button" class="anchor" href="#button"><span class="octicon octicon-link"></span></a>Button</h4>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/ButtonOverview.png" alt="Button"></p>

<p>uGUI里，Button控件由两个GameObject组成，一个包含Image, Button等Component，一个包含Text等Component。这样设计很组件化，唯一的问题是当用户想修改Button时，容易不小心选中Label或其它实体。</p>

<p>Button Component主要执行Transition和事件两个操作。</p>

<ul>
<li>
<strong>Transition</strong>可选择改变颜色、更换贴图或自定义动画，使用起来简单方便，也能利用动画定义更丰富的表现。我会再写一篇文章演示Button的Transition。</li>
<li>
<strong>事件</strong>也是所见即所得的，在OnClick里面可以添加多个命令，命令可以选择对应的目标、操作和参数。用法简单，有需要也可以换程序控制。

<ul>
<li>目标可以是任意Object，例如其它GameObject或者Project里的Asset</li>
<li>操作可以是需要设置的参数或调用的方法</li>
<li>参数分成Dynamic和Static，Dynamic能将控件的参数<strong>单向绑定</strong>到目标参数，Static则将目标参数设置成预设值。按钮没有Dynamic参数，Toggle, Slider等控件才有。</li>
</ul>
</li>
</ul><h1>
<a name="%E4%BA%8B%E4%BB%B6" class="anchor" href="#%E4%BA%8B%E4%BB%B6"><span class="octicon octicon-link"></span></a>事件</h1>

<h4>
<a name="event-trigger" class="anchor" href="#event-trigger"><span class="octicon octicon-link"></span></a>Event Trigger</h4>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/EventTrigger.png" alt="Event Trigger"></p>

<p>uGUI控件往往只提供一个<strong>自带事件</strong>，要响应更多<strong>基本事件</strong>的话，需要添加Event Trigger组件。Event Trigger包含以下事件：</p>

<ul>
<li>PointerEnter, PointerExit,    PointerDown,    PointerUp,  PointerClick</li>
<li>Move, Drag,   Drop,   Scroll</li>
<li>KeyDown,  KeyUp,  Select, Deselect</li>
</ul><p>可以在Event Trigger中Add多个事件，每个事件都可以添加多个命令，用法和控件自带事件一致。</p>

<h4>
<a name="graphic-raycaster" class="anchor" href="#graphic-raycaster"><span class="octicon octicon-link"></span></a>Graphic Raycaster</h4>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/GraphicRaycaster.png" alt="Graphic Raycaster"></p>

<p>每个Canvas都有一个Graphic Raycaster，用于获取用户选中的uGUI控件。多个Canvas之间通过设置Graphic Raycaster的priority来设置事件响应的先后次序。当Canvas采用World Space或Camera Space时，Graphic Raycaster的Block选项可以用来设置遮挡目标。</p>

<h4>
<a name="event-system" class="anchor" href="#event-system"><span class="octicon octicon-link"></span></a>Event System</h4>

<p><img src="https://raw.githubusercontent.com/jaredoc/unity-ugui/master/overview/img/EventSystem.png" alt="Event System"></p>

<p>创建uGUI控件后，Unity会同时创建一个[<a href="#eventSys">注4</a>]叫EventSystem的GameObject，用于控制各类事件。可以看到Unity自带了两个Input Module，一个用于响应标准输入，一个用于响应触摸操作。Input Module封装了对Input模块的调用，根据用户操作触发各<strong>Event Trigger</strong>。理论上我们可以编写自己的Input Module，用来封装各种外部设备的输入，只要加入Event System所在的GameObject就行。</p>

<p>Event System组件则统一管理多个Input Module和<strong>各种Raycaster</strong>。它每一帧调用多个Input Module处理用户操作，也负责调用多个Raycaster用于获取用户点击的uGUI控件以及2D和3D物体。</p>

<h1>
<a name="%E6%80%A7%E8%83%BD" class="anchor" href="#%E6%80%A7%E8%83%BD"><span class="octicon octicon-link"></span></a>性能</h1>

<p>2D渲染分两大类，一类是单纯的Sprite绘制，用于渲染场景、角色、粒子等，另一类是UI绘制。Unity将这两类需求划分成了<strong>SpriteRenderer</strong>和<strong>uGUI</strong>两部分，前者由<strong>Transform</strong> + <strong>SpriteRenderer</strong>实现，后者由<strong>Rect Transform</strong> + <strong>CanvasRenderer</strong> + <strong>UI控件</strong> + <strong>Canvas[<a href="#why_canvas">注2</a>]</strong>实现，这样的两套相对独立的机制比起X-UI的UI控件继承自SpriteRenderer更为合理。因为在2D游戏里SpriteRenderer只需要关心最基本的面片渲染，注重效率，而UI注重各类变换、对齐、操作、动画，还常常需要Resize VBO。如果SpriteRenderer在设计上需要兼顾UI，就会像X-UI那样设计得太过复杂，在用户体验和性能上都很不好。</p>

<p>这里我们探讨一下uGUI的<strong>渲染机制</strong>，当我们渲染多个使用相同Sprite的控件时，并没发生dynamic batching，但是drawcall也没有上升。这就说明Unity在内部使用了专门的一套batching机制，把多个控件的VBO事先合并成了一个。也就是说CanvasRenderer不负责实际渲染，而是由Canvas批量渲染多个CanvasRenderer，这和部分X-UI采用的做法一致。这样单独batch的设计有可能使得性能比SpriteRenderer好，也可能导致性能更差。性能会更好的情况在ex2D里已经证实了，主要原因是这样能更好的<strong>平衡CPU和GPU负载</strong>，并且能做到<strong>更优化的batching算法</strong>。性能更差的情况，在去年旧版的NGUI测试时也遇到了，根本原因还是优化不到位导致的（不是贬低，不同工具的取舍和面向市场都不同）。而Unity的SpriteRenderer在手机上的渲染跑分是和ex2D持平的，CanvasRenderer又比SpriteRenderer快[<a href="#why_CanvasRenderer_better">注3</a>]，因此uGUI的性能不用担心。由于目前没有Mac版本，我会在正式版发布后进行一次手机跑分测试。</p>

<h1>
<a name="%E5%B0%8F%E7%BB%93" class="anchor" href="#%E5%B0%8F%E7%BB%93"><span class="octicon octicon-link"></span></a>小结</h1>

<p>uGUI功能完善，操作简洁，很接地气。可以说uGUI是相对X-UI的全面升级，整体架构更为严谨，实现更为清晰。依托4.5的Module Manager，uGUI以Package的形式提供，也能获得快速的升级[<a href="#package">注5</a>]。作为ex2D v2.0开发者之一，我很看好它将来的发展，uGUI将在大多数场合取代X-UI。</p>

<p>初步感受：</p>

<h4>
<a name="%E4%BA%AE%E7%82%B9" class="anchor" href="#%E4%BA%AE%E7%82%B9"><span class="octicon octicon-link"></span></a>亮点</h4>

<ul>
<li>RectTransform</li>
<li>Event/单向数据绑定</li>
<li>直接在Hierarchy中排序</li>
<li>Pro用户可用Sprite的动态拼图，无需手工拼图</li>
</ul><h4>
<a name="%E5%B0%8F%E9%97%AE%E9%A2%98" class="anchor" href="#%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="octicon octicon-link"></span></a>小问题</h4>

<ul>
<li>Anchor Presets面板还不够直观。</li>
<li>用户想修改Button时，很容易修改到Label。</li>
<li>Input组件对方向键的支持有问题。</li>
<li>当Hierarchy面板内的目标节点展开子节点后，无法将其它节点直接拖动到目标的正下方。</li>
</ul><h1>
<a name="%E9%99%84%E6%B3%A8" class="anchor" href="#%E9%99%84%E6%B3%A8"><span class="octicon octicon-link"></span></a>附注</h1>

<ol>
<li>
<a name="why_transform"></a>我们在其它平台上开发类Entity-Component框架时，讨论过Unity为什么不在底层对transform做特殊处理，以避免插件作者手工缓存transform来优化query transform引起的开销，甚至是将transform直接整合进GameObject。原因是现在的transform是3D的，将来完全可能推出2D Transform。所以Unity在之前的版本里一直保留着transform的独立性。</li>
<li>
<a name="why_canvas"></a>我不能完全肯定一定是Canvas，但通过Canvas和CanvasRenderer的接口来看，这个可能性很大。</li>
<li>
<a name="why_CanvasRenderer_better"></a>基于更好的平衡CPU和GPU负载 + 更优化的batching算法，以Unity的实力CanvasRenderer超越SpriteRenderer问题不大。而且如果性能不会提升，uGUI只要像<strong>2D Toolkit</strong>那样给每个控件直接添加MeshRenderer，也就是说uGUI直接用已有的SpriteRenderer就好，不太可能加入新的CanvasRenderer性能反而更慢。</li>
<li>
<a name="eventSys"></a>Unity允许多个Event System同时存在，但同一时刻只有一个能够生效。</li>
<li>
<a name="package"></a>uGUI的控件、Event等模块以包的形式提供，位于程序目录下的<em>%UNITY%\Editor\Data\UnityExtensions\Unity\GUISystem\4.6.0</em>，Unity提供了两个运行时版本的DLL，分别用于创作和发布。区别主要是发布版不含一些Editor中才用得到的代码。由于DLL没办法通过预编译符号来进行条件编译，因此Unity使用这种方式进行权衡，用户发布时无需手工切换DLL版本，满足了闭源，又兼顾了执行效率。<del>这样就甩开了第三方插件几条街，很多插件在这个问题上不是牺牲性能就是无奈开源。</del>
</li>
</ol><blockquote>
<p><a href="http://weibo.com/u/1751917933">Jare</a> @ <a href="http://www.mechanist.co/cn/">梦加网络</a></p>

<p>本文托管于 <a href="https://github.com/jaredoc/unity-ugui/tree/master/overview">https://github.com/jaredoc/unity-ugui/tree/master/overview</a> 欢迎Fork、提Issue或转载</p>
</blockquote>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Evaluation of the Unity 4.6 New UI System maintained by <a href="https://github.com/jaredoc">jaredoc</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
